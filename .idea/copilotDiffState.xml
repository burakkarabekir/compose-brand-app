<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/data/repository/SearchRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/data/repository/SearchRepository.kt" />
              <option name="originalContent" value="package com.bksd.brandapp.data.repository&#10;&#10;import com.bksd.brandapp.domain.model.ItemDetail&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.SearchResponse&#10;import com.bksd.brandapp.network.api.ApiService&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;&#10;/**&#10; * Repository interface for search and detail operations&#10; */&#10;interface SearchRepository {&#10;    suspend fun search(&#10;        query: String,&#10;        page: Int = 1,&#10;        limit: Int = 20,&#10;        category: String? = null,&#10;        sortBy: String? = null&#10;    ): Flow&lt;NetworkResult&lt;SearchResponse&gt;&gt;&#10;&#10;    suspend fun getItemDetail(itemId: String): Flow&lt;NetworkResult&lt;ItemDetail&gt;&gt;&#10;&#10;    fun clearCache()&#10;}&#10;&#10;/**&#10; * Implementation of SearchRepository with caching capabilities&#10; */&#10;class SearchRepositoryImpl(&#10;    private val apiService: ApiService&#10;) : SearchRepository {&#10;&#10;    // Simple in-memory cache for demonstration&#10;    // In production, consider using Room database or DataStore&#10;    private val searchCache = mutableMapOf&lt;String, SearchResponse&gt;()&#10;    private val detailCache = mutableMapOf&lt;String, ItemDetail&gt;()&#10;&#10;    override suspend fun search(&#10;        query: String,&#10;        page: Int,&#10;        limit: Int,&#10;        category: String?,&#10;        sortBy: String?&#10;    ): Flow&lt;NetworkResult&lt;SearchResponse&gt;&gt; = flow {&#10;        val cacheKey = buildCacheKey(query, page, limit, category, sortBy)&#10;&#10;        // Emit cached data first if available&#10;        searchCache[cacheKey]?.let { cachedResult -&gt;&#10;            emit(NetworkResult.Success(cachedResult))&#10;        }&#10;&#10;        // Emit loading state&#10;        emit(NetworkResult.Loading)&#10;&#10;        // Fetch from network&#10;        val networkResult = apiService.search(query, page, limit, category, sortBy)&#10;&#10;        // Cache successful results&#10;        if (networkResult is NetworkResult.Success) {&#10;            searchCache[cacheKey] = networkResult.data&#10;        }&#10;&#10;        emit(networkResult)&#10;    }&#10;&#10;    override suspend fun getItemDetail(itemId: String): Flow&lt;NetworkResult&lt;ItemDetail&gt;&gt; = flow {&#10;        // Emit cached data first if available&#10;        detailCache[itemId]?.let { cachedDetail -&gt;&#10;            emit(NetworkResult.Success(cachedDetail))&#10;        }&#10;&#10;        // Emit loading state&#10;        emit(NetworkResult.Loading)&#10;&#10;        // Fetch from network&#10;        val networkResult = apiService.getItemDetail(itemId)&#10;&#10;        // Cache successful results&#10;        if (networkResult is NetworkResult.Success) {&#10;            detailCache[itemId] = networkResult.data&#10;        }&#10;&#10;        emit(networkResult)&#10;    }&#10;&#10;    override fun clearCache() {&#10;        searchCache.clear()&#10;        detailCache.clear()&#10;    }&#10;&#10;    private fun buildCacheKey(&#10;        query: String,&#10;        page: Int,&#10;        limit: Int,&#10;        category: String?,&#10;        sortBy: String?&#10;    ): String {&#10;        return buildString {&#10;            append(query)&#10;            append(&quot;_page_$page&quot;)&#10;            append(&quot;_limit_$limit&quot;)&#10;            category?.let { append(&quot;_cat_$it&quot;) }&#10;            sortBy?.let { append(&quot;_sort_$it&quot;) }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.bksd.brandapp.data.repository&#10;&#10;import com.bksd.brandapp.domain.model.ItemDetail&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.SearchResponse&#10;import com.bksd.brandapp.network.api.ApiService&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;&#10;/**&#10; * Repository interface for search and detail operations&#10; */&#10;interface SearchRepository {&#10;    suspend fun search(&#10;        query: String,&#10;        page: Int = 1,&#10;        limit: Int = 20,&#10;        category: String? = null,&#10;        sortBy: String? = null&#10;    ): Flow&lt;NetworkResult&lt;SearchResponse&gt;&gt;&#10;&#10;    suspend fun getItemDetail(itemId: String): Flow&lt;NetworkResult&lt;ItemDetail&gt;&gt;&#10;&#10;    fun clearCache()&#10;}&#10;&#10;/**&#10; * Implementation of SearchRepository without caching&#10; */&#10;class SearchRepositoryImpl(&#10;    private val apiService: ApiService&#10;) : SearchRepository {&#10;&#10;    override suspend fun search(&#10;        query: String,&#10;        page: Int,&#10;        limit: Int,&#10;        category: String?,&#10;        sortBy: String?&#10;    ): Flow&lt;NetworkResult&lt;SearchResponse&gt;&gt; = flow {&#10;        // Emit loading state&#10;        emit(NetworkResult.Loading)&#10;&#10;        // Fetch from network&#10;        val networkResult = apiService.search(query, page, limit, category, sortBy)&#10;&#10;        emit(networkResult)&#10;    }&#10;&#10;    override suspend fun getItemDetail(itemId: String): Flow&lt;NetworkResult&lt;ItemDetail&gt;&gt; = flow {&#10;        // Emit loading state&#10;        emit(NetworkResult.Loading)&#10;&#10;        // Fetch from network&#10;        val networkResult = apiService.getItemDetail(itemId)&#10;&#10;        emit(networkResult)&#10;    }&#10;&#10;    override fun clearCache() {&#10;        // No cache to clear&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/data/repository/brandfetch/BrandfetchRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/data/repository/brandfetch/BrandfetchRepository.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.data.repository.brandfetch&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchBrandDetail&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchSearchResponse&#10;import com.bksd.brandapp.network.api.brandfetch.BrandfetchApiService&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;&#10;/**&#10; * Repository interface for Brandfetch operations&#10; */&#10;interface BrandfetchRepository {&#10;    suspend fun searchBrands(&#10;        query: String,&#10;        count: Int = 1&#10;    ): Flow&lt;NetworkResult&lt;BrandfetchSearchResponse&gt;&gt;&#10;    &#10;    suspend fun getBrandDetail(brandName: String): Flow&lt;NetworkResult&lt;BrandfetchBrandDetail&gt;&gt;&#10;    &#10;    fun clearCache()&#10;}&#10;&#10;/**&#10; * Implementation of BrandfetchRepository with caching capabilities&#10; */&#10;class BrandfetchRepositoryImpl(&#10;    private val brandfetchApiService: BrandfetchApiService&#10;) : BrandfetchRepository {&#10;    &#10;    // Simple in-memory cache for Brandfetch data&#10;    private val searchCache = mutableMapOf&lt;String, BrandfetchSearchResponse&gt;()&#10;    private val brandDetailCache = mutableMapOf&lt;String, BrandfetchBrandDetail&gt;()&#10;    &#10;    override suspend fun searchBrands(&#10;        query: String,&#10;        count: Int&#10;    ): Flow&lt;NetworkResult&lt;BrandfetchSearchResponse&gt;&gt; = flow {&#10;        val cacheKey = &quot;${query.lowercase()}_count_$count&quot;&#10;        &#10;        // Emit cached data first if available&#10;        searchCache[cacheKey]?.let { cachedResult -&gt;&#10;            emit(NetworkResult.Success(cachedResult))&#10;        }&#10;        &#10;        // Emit loading state&#10;        emit(NetworkResult.Loading)&#10;        &#10;        // Fetch from network&#10;        val networkResult = brandfetchApiService.searchBrands(query, count)&#10;        &#10;        // Cache successful results&#10;        if (networkResult is NetworkResult.Success) {&#10;            searchCache[cacheKey] = networkResult.data&#10;        }&#10;        &#10;        emit(networkResult)&#10;    }&#10;    &#10;    override suspend fun getBrandDetail(brandName: String): Flow&lt;NetworkResult&lt;BrandfetchBrandDetail&gt;&gt; = flow {&#10;        val cacheKey = brandName.lowercase()&#10;        &#10;        // Emit cached data first if available&#10;        brandDetailCache[cacheKey]?.let { cachedDetail -&gt;&#10;            emit(NetworkResult.Success(cachedDetail))&#10;        }&#10;        &#10;        // Emit loading state&#10;        emit(NetworkResult.Loading)&#10;        &#10;        // Fetch from network&#10;        val networkResult = brandfetchApiService.getBrandDetail(brandName)&#10;        &#10;        // Cache successful results&#10;        if (networkResult is NetworkResult.Success) {&#10;            brandDetailCache[cacheKey] = networkResult.data&#10;        }&#10;        &#10;        emit(networkResult)&#10;    }&#10;    &#10;    override fun clearCache() {&#10;        searchCache.clear()&#10;        brandDetailCache.clear()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/ItemDetail.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/ItemDetail.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.model&#10;&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;&#10;/**&#10; * Domain model representing detailed information about an item&#10; */&#10;@Serializable&#10;data class ItemDetail(&#10;    @SerialName(&quot;id&quot;)&#10;    val id: String,&#10;    @SerialName(&quot;title&quot;)&#10;    val title: String,&#10;    @SerialName(&quot;description&quot;)&#10;    val description: String,&#10;    @SerialName(&quot;longDescription&quot;)&#10;    val longDescription: String? = null,&#10;    @SerialName(&quot;imageUrls&quot;)&#10;    val imageUrls: List&lt;String&gt; = emptyList(),&#10;    @SerialName(&quot;category&quot;)&#10;    val category: String? = null,&#10;    @SerialName(&quot;rating&quot;)&#10;    val rating: Double? = null,&#10;    @SerialName(&quot;reviewCount&quot;)&#10;    val reviewCount: Int? = null,&#10;    @SerialName(&quot;price&quot;)&#10;    val price: Double? = null,&#10;    @SerialName(&quot;currency&quot;)&#10;    val currency: String? = null,&#10;    @SerialName(&quot;tags&quot;)&#10;    val tags: List&lt;String&gt; = emptyList(),&#10;    @SerialName(&quot;createdAt&quot;)&#10;    val createdAt: String? = null,&#10;    @SerialName(&quot;updatedAt&quot;)&#10;    val updatedAt: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/NetworkResult.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/NetworkResult.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.model&#10;&#10;/**&#10; * Sealed class representing the result of a network operation&#10; */&#10;sealed class NetworkResult&lt;out T&gt; {&#10;    data class Success&lt;T&gt;(val data: T) : NetworkResult&lt;T&gt;()&#10;    data class Error(val exception: NetworkException) : NetworkResult&lt;Nothing&gt;()&#10;    data object Loading : NetworkResult&lt;Nothing&gt;()&#10;}&#10;&#10;/**&#10; * Custom exception classes for different types of network errors&#10; */&#10;sealed class NetworkException(&#10;    message: String,&#10;    cause: Throwable? = null&#10;) : Exception(message, cause) {&#10;    &#10;    data class HttpException(&#10;        val code: Int,&#10;        val errorMessage: String&#10;    ) : NetworkException(&quot;HTTP $code: $errorMessage&quot;)&#10;    &#10;    data class NetworkException(&#10;        val errorMessage: String,&#10;        val cause: Throwable? = null&#10;    ) : NetworkException(&quot;Network error: $errorMessage&quot;, cause)&#10;    &#10;    data class TimeoutException(&#10;        val errorMessage: String = &quot;Request timeout&quot;&#10;    ) : NetworkException(errorMessage)&#10;    &#10;    data class UnknownException(&#10;        val errorMessage: String,&#10;        val cause: Throwable? = null&#10;    ) : NetworkException(&quot;Unknown error: $errorMessage&quot;, cause)&#10;    &#10;    data class ParseException(&#10;        val errorMessage: String,&#10;        val cause: Throwable? = null&#10;    ) : NetworkException(&quot;Parse error: $errorMessage&quot;, cause)&#10;}&#10;&#10;/**&#10; * Extension function to map network results&#10; */&#10;inline fun &lt;T, R&gt; NetworkResult&lt;T&gt;.map(transform: (T) -&gt; R): NetworkResult&lt;R&gt; {&#10;    return when (this) {&#10;        is NetworkResult.Success -&gt; NetworkResult.Success(transform(data))&#10;        is NetworkResult.Error -&gt; this&#10;        is NetworkResult.Loading -&gt; this&#10;    }&#10;}&#10;&#10;/**&#10; * Extension function to handle network results with success and error callbacks&#10; */&#10;inline fun &lt;T&gt; NetworkResult&lt;T&gt;.onSuccess(action: (T) -&gt; Unit): NetworkResult&lt;T&gt; {&#10;    if (this is NetworkResult.Success) action(data)&#10;    return this&#10;}&#10;&#10;inline fun &lt;T&gt; NetworkResult&lt;T&gt;.onError(action: (NetworkException) -&gt; Unit): NetworkResult&lt;T&gt; {&#10;    if (this is NetworkResult.Error) action(exception)&#10;    return this&#10;}&#10;&#10;inline fun &lt;T&gt; NetworkResult&lt;T&gt;.onLoading(action: () -&gt; Unit): NetworkResult&lt;T&gt; {&#10;    if (this is NetworkResult.Loading) action()&#10;    return this&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/SearchResult.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/SearchResult.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.model&#10;&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;&#10;/**&#10; * Domain model representing a search result item&#10; */&#10;@Serializable&#10;data class SearchResult(&#10;    @SerialName(&quot;id&quot;)&#10;    val id: String,&#10;    @SerialName(&quot;title&quot;)&#10;    val title: String,&#10;    @SerialName(&quot;description&quot;)&#10;    val description: String,&#10;    @SerialName(&quot;imageUrl&quot;)&#10;    val imageUrl: String? = null,&#10;    @SerialName(&quot;category&quot;)&#10;    val category: String? = null,&#10;    @SerialName(&quot;rating&quot;)&#10;    val rating: Double? = null&#10;)&#10;&#10;/**&#10; * Domain model representing the search response&#10; */&#10;@Serializable&#10;data class SearchResponse(&#10;    @SerialName(&quot;results&quot;)&#10;    val results: List&lt;SearchResult&gt;,&#10;    @SerialName(&quot;totalCount&quot;)&#10;    val totalCount: Int,&#10;    @SerialName(&quot;page&quot;)&#10;    val page: Int,&#10;    @SerialName(&quot;hasMore&quot;)&#10;    val hasMore: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/brandfetch/BrandfetchModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/model/brandfetch/BrandfetchModels.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.model.brandfetch&#10;&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;&#10;/**&#10; * Brandfetch search result model&#10; */&#10;@Serializable&#10;data class BrandfetchSearchResult(&#10;    @SerialName(&quot;name&quot;)&#10;    val name: String,&#10;    @SerialName(&quot;domain&quot;)&#10;    val domain: String,&#10;    @SerialName(&quot;claimed&quot;)&#10;    val claimed: Boolean = false,&#10;    @SerialName(&quot;description&quot;)&#10;    val description: String? = null,&#10;    @SerialName(&quot;longDescription&quot;)&#10;    val longDescription: String? = null,&#10;    @SerialName(&quot;links&quot;)&#10;    val links: List&lt;BrandfetchLink&gt; = emptyList(),&#10;    @SerialName(&quot;logos&quot;)&#10;    val logos: List&lt;BrandfetchLogo&gt; = emptyList(),&#10;    @SerialName(&quot;colors&quot;)&#10;    val colors: List&lt;BrandfetchColor&gt; = emptyList(),&#10;    @SerialName(&quot;fonts&quot;)&#10;    val fonts: List&lt;BrandfetchFont&gt; = emptyList(),&#10;    @SerialName(&quot;images&quot;)&#10;    val images: List&lt;BrandfetchImage&gt; = emptyList()&#10;)&#10;&#10;/**&#10; * Brandfetch search response model&#10; */&#10;@Serializable&#10;data class BrandfetchSearchResponse(&#10;    @SerialName(&quot;brands&quot;)&#10;    val brands: List&lt;BrandfetchSearchResult&gt; = emptyList()&#10;)&#10;&#10;/**&#10; * Brandfetch brand detail model (same structure as search result but more complete)&#10; */&#10;@Serializable&#10;data class BrandfetchBrandDetail(&#10;    @SerialName(&quot;name&quot;)&#10;    val name: String,&#10;    @SerialName(&quot;domain&quot;)&#10;    val domain: String,&#10;    @SerialName(&quot;claimed&quot;)&#10;    val claimed: Boolean = false,&#10;    @SerialName(&quot;description&quot;)&#10;    val description: String? = null,&#10;    @SerialName(&quot;longDescription&quot;)&#10;    val longDescription: String? = null,&#10;    @SerialName(&quot;links&quot;)&#10;    val links: List&lt;BrandfetchLink&gt; = emptyList(),&#10;    @SerialName(&quot;logos&quot;)&#10;    val logos: List&lt;BrandfetchLogo&gt; = emptyList(),&#10;    @SerialName(&quot;colors&quot;)&#10;    val colors: List&lt;BrandfetchColor&gt; = emptyList(),&#10;    @SerialName(&quot;fonts&quot;)&#10;    val fonts: List&lt;BrandfetchFont&gt; = emptyList(),&#10;    @SerialName(&quot;images&quot;)&#10;    val images: List&lt;BrandfetchImage&gt; = emptyList(),&#10;    @SerialName(&quot;company&quot;)&#10;    val company: BrandfetchCompany? = null&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchLink(&#10;    @SerialName(&quot;name&quot;)&#10;    val name: String,&#10;    @SerialName(&quot;url&quot;)&#10;    val url: String&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchLogo(&#10;    @SerialName(&quot;theme&quot;)&#10;    val theme: String? = null,&#10;    @SerialName(&quot;formats&quot;)&#10;    val formats: List&lt;BrandfetchLogoFormat&gt; = emptyList()&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchLogoFormat(&#10;    @SerialName(&quot;src&quot;)&#10;    val src: String,&#10;    @SerialName(&quot;background&quot;)&#10;    val background: String? = null,&#10;    @SerialName(&quot;format&quot;)&#10;    val format: String? = null,&#10;    @SerialName(&quot;height&quot;)&#10;    val height: Int? = null,&#10;    @SerialName(&quot;width&quot;)&#10;    val width: Int? = null,&#10;    @SerialName(&quot;size&quot;)&#10;    val size: Int? = null&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchColor(&#10;    @SerialName(&quot;hex&quot;)&#10;    val hex: String,&#10;    @SerialName(&quot;type&quot;)&#10;    val type: String? = null,&#10;    @SerialName(&quot;brightness&quot;)&#10;    val brightness: Int? = null&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchFont(&#10;    @SerialName(&quot;name&quot;)&#10;    val name: String,&#10;    @SerialName(&quot;type&quot;)&#10;    val type: String? = null,&#10;    @SerialName(&quot;origin&quot;)&#10;    val origin: String? = null,&#10;    @SerialName(&quot;originId&quot;)&#10;    val originId: String? = null,&#10;    @SerialName(&quot;weights&quot;)&#10;    val weights: List&lt;String&gt; = emptyList()&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchImage(&#10;    @SerialName(&quot;name&quot;)&#10;    val name: String? = null,&#10;    @SerialName(&quot;src&quot;)&#10;    val src: String,&#10;    @SerialName(&quot;type&quot;)&#10;    val type: String? = null&#10;)&#10;&#10;@Serializable&#10;data class BrandfetchCompany(&#10;    @SerialName(&quot;employees&quot;)&#10;    val employees: String? = null,&#10;    @SerialName(&quot;foundedYear&quot;)&#10;    val foundedYear: Int? = null,&#10;    @SerialName(&quot;industry&quot;)&#10;    val industry: String? = null,&#10;    @SerialName(&quot;keyPeople&quot;)&#10;    val keyPeople: List&lt;String&gt; = emptyList()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/GetItemDetailUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/GetItemDetailUseCase.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.usecase&#10;&#10;import com.bksd.brandapp.data.repository.SearchRepository&#10;import com.bksd.brandapp.domain.model.ItemDetail&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Use case for getting item details with business logic&#10; */&#10;class GetItemDetailUseCase(&#10;    private val searchRepository: SearchRepository&#10;) {&#10;    &#10;    suspend operator fun invoke(itemId: String): Flow&lt;NetworkResult&lt;ItemDetail&gt;&gt; {&#10;        // Add business logic validation&#10;        require(itemId.isNotBlank()) { &quot;Item ID cannot be blank&quot; }&#10;        &#10;        return searchRepository.getItemDetail(itemId.trim())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/SearchItemsUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/SearchItemsUseCase.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.usecase&#10;&#10;import com.bksd.brandapp.data.repository.SearchRepository&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.SearchResponse&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Use case for searching items with business logic&#10; */&#10;class SearchItemsUseCase(&#10;    private val searchRepository: SearchRepository&#10;) {&#10;    &#10;    suspend operator fun invoke(&#10;        query: String,&#10;        page: Int = 1,&#10;        limit: Int = 20,&#10;        category: String? = null,&#10;        sortBy: String? = null&#10;    ): Flow&lt;NetworkResult&lt;SearchResponse&gt;&gt; {&#10;        // Add business logic validation&#10;        require(query.isNotBlank()) { &quot;Search query cannot be blank&quot; }&#10;        require(page &gt; 0) { &quot;Page number must be positive&quot; }&#10;        require(limit in 1..100) { &quot;Limit must be between 1 and 100&quot; }&#10;        &#10;        return searchRepository.search(&#10;            query = query.trim(),&#10;            page = page,&#10;            limit = limit,&#10;            category = category,&#10;            sortBy = sortBy&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/brandfetch/GetBrandDetailUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/brandfetch/GetBrandDetailUseCase.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.usecase.brandfetch&#10;&#10;import com.bksd.brandapp.data.repository.brandfetch.BrandfetchRepository&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchBrandDetail&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Use case for getting brand details using Brandfetch API&#10; */&#10;class GetBrandDetailUseCase(&#10;    private val brandfetchRepository: BrandfetchRepository&#10;) {&#10;    &#10;    suspend operator fun invoke(&#10;        brandName: String&#10;    ): Flow&lt;NetworkResult&lt;BrandfetchBrandDetail&gt;&gt; {&#10;        // Business logic validation&#10;        require(brandName.isNotBlank()) { &quot;Brand name cannot be blank&quot; }&#10;        &#10;        return brandfetchRepository.getBrandDetail(brandName.trim())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/brandfetch/SearchBrandsUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/domain/usecase/brandfetch/SearchBrandsUseCase.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.domain.usecase.brandfetch&#10;&#10;import com.bksd.brandapp.data.repository.brandfetch.BrandfetchRepository&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchSearchResponse&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Use case for searching brands using Brandfetch API&#10; */&#10;class SearchBrandsUseCase(&#10;    private val brandfetchRepository: BrandfetchRepository&#10;) {&#10;    &#10;    suspend operator fun invoke(&#10;        query: String,&#10;        count: Int = 1&#10;    ): Flow&lt;NetworkResult&lt;BrandfetchSearchResponse&gt;&gt; {&#10;        // Business logic validation&#10;        require(query.isNotBlank()) { &quot;Search query cannot be blank&quot; }&#10;        require(count in 1..10) { &quot;Count must be between 1 and 10&quot; }&#10;        &#10;        return brandfetchRepository.searchBrands(&#10;            query = query.trim(),&#10;            count = count&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/NetworkClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/NetworkClient.kt" />
              <option name="originalContent" value="&#10;import com.bksd.brandapp.domain.model.NetworkException&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import io.ktor.client.*&#10;import io.ktor.client.call.*&#10;import io.ktor.client.plugins.*&#10;import io.ktor.client.request.*&#10;import io.ktor.client.statement.*&#10;import io.ktor.http.*&#10;import io.ktor.serialization.*&#10;import kotlinx.coroutines.CancellationException&#10;import kotlinx.coroutines.TimeoutCancellationException&#10;import timber.log.Timber&#10;import java.net.ConnectException&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;&#10;/**&#10; * Network client interface for making HTTP requests&#10; */&#10;interface NetworkClient {&#10;    suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;    &#10;    suspend fun &lt;T&gt; post(&#10;        path: String,&#10;        body: Any? = null,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;    &#10;    suspend fun &lt;T&gt; put(&#10;        path: String,&#10;        body: Any? = null,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;    &#10;    suspend fun &lt;T&gt; delete(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;}&#10;&#10;/**&#10; * Implementation of NetworkClient using Ktor HttpClient&#10; */&#10;class KtorNetworkClient(&#10;    private val httpClient: HttpClient&#10;) : NetworkClient {&#10;    &#10;    override suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.get(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; post(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.post(path) {&#10;            body?.let { setBody(it) }&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; put(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.put(path) {&#10;            body?.let { setBody(it) }&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; delete(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.delete(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Safe API call wrapper that handles exceptions and converts them to NetworkResult&#10;     */&#10;    private suspend inline fun &lt;reified T&gt; safeApiCall(&#10;        apiCall: () -&gt; HttpResponse&#10;    ): NetworkResult&lt;T&gt; {&#10;        return try {&#10;            val response = apiCall()&#10;            when {&#10;                response.status.isSuccess() -&gt; {&#10;                    val body = response.body&lt;T&gt;()&#10;                    NetworkResult.Success(body)&#10;                }&#10;                else -&gt; {&#10;                    val errorBody = try {&#10;                        response.bodyAsText()&#10;                    } catch (e: Exception) {&#10;                        &quot;Unknown error&quot;&#10;                    }&#10;                    NetworkResult.Error(&#10;                        NetworkException.HttpException(&#10;                            code = response.status.value,&#10;                            errorMessage = errorBody&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        } catch (e: CancellationException) {&#10;            // Don't catch cancellation exceptions - let them propagate&#10;            throw e&#10;        } catch (e: TimeoutCancellationException) {&#10;            Timber.e(e, &quot;Request timeout&quot;)&#10;            NetworkResult.Error(NetworkException.TimeoutException())&#10;        } catch (e: SocketTimeoutException) {&#10;            Timber.e(e, &quot;Socket timeout&quot;)&#10;            NetworkResult.Error(NetworkException.TimeoutException(&quot;Socket timeout&quot;))&#10;        } catch (e: UnknownHostException) {&#10;            Timber.e(e, &quot;Unknown host&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.NetworkException(&#10;                    &quot;No internet connection or server unreachable&quot;,&#10;                    e&#10;                )&#10;            )&#10;        } catch (e: ConnectException) {&#10;            Timber.e(e, &quot;Connection failed&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.NetworkException(&#10;                    &quot;Failed to connect to server&quot;,&#10;                    e&#10;                )&#10;            )&#10;        } catch (e: JsonConvertException) {&#10;            Timber.e(e, &quot;JSON parsing error&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.ParseException(&#10;                    &quot;Failed to parse response&quot;,&#10;                    e&#10;                )&#10;            )&#10;        } catch (e: Exception) {&#10;            Timber.e(e, &quot;Unknown network error&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.UnknownException(&#10;                    e.message ?: &quot;Unknown error occurred&quot;,&#10;                    e&#10;                )&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.bksd.brandapp.network&#10;&#10;import com.bksd.brandapp.domain.model.NetworkException&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import io.ktor.client.*&#10;import io.ktor.client.call.*&#10;import io.ktor.client.plugins.*&#10;import io.ktor.client.request.*&#10;import io.ktor.client.statement.*&#10;import io.ktor.http.*&#10;import io.ktor.serialization.*&#10;import kotlinx.coroutines.CancellationException&#10;import kotlinx.coroutines.TimeoutCancellationException&#10;import timber.log.Timber&#10;import java.net.ConnectException&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;&#10;/**&#10; * Network client interface for making HTTP requests&#10; */&#10;interface NetworkClient {&#10;    suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;    &#10;    suspend fun &lt;T&gt; post(&#10;        path: String,&#10;        body: Any? = null,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;    &#10;    suspend fun &lt;T&gt; put(&#10;        path: String,&#10;        body: Any? = null,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;    &#10;    suspend fun &lt;T&gt; delete(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;}&#10;&#10;/**&#10; * Implementation of NetworkClient using Ktor HttpClient&#10; */&#10;class KtorNetworkClient(&#10;    private val httpClient: HttpClient&#10;) : NetworkClient {&#10;    &#10;    override suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.get(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; post(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.post(path) {&#10;            body?.let { setBody(it) }&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; put(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.put(path) {&#10;            body?.let { setBody(it) }&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; delete(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = safeApiCall {&#10;        httpClient.delete(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Safe API call wrapper that handles exceptions and converts them to NetworkResult&#10;     */&#10;    private suspend inline fun &lt;reified T&gt; safeApiCall(&#10;        apiCall: () -&gt; HttpResponse&#10;    ): NetworkResult&lt;T&gt; {&#10;        return try {&#10;            val response = apiCall()&#10;            when {&#10;                response.status.isSuccess() -&gt; {&#10;                    val body = response.body&lt;T&gt;()&#10;                    NetworkResult.Success(body)&#10;                }&#10;                else -&gt; {&#10;                    val errorBody = try {&#10;                        response.bodyAsText()&#10;                    } catch (e: Exception) {&#10;                        &quot;Unknown error&quot;&#10;                    }&#10;                    NetworkResult.Error(&#10;                        NetworkException.HttpException(&#10;                            code = response.status.value,&#10;                            errorMessage = errorBody&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        } catch (e: CancellationException) {&#10;            // Don't catch cancellation exceptions - let them propagate&#10;            throw e&#10;        } catch (e: TimeoutCancellationException) {&#10;            Timber.e(e, &quot;Request timeout&quot;)&#10;            NetworkResult.Error(NetworkException.TimeoutException())&#10;        } catch (e: SocketTimeoutException) {&#10;            Timber.e(e, &quot;Socket timeout&quot;)&#10;            NetworkResult.Error(NetworkException.TimeoutException(&quot;Socket timeout&quot;))&#10;        } catch (e: UnknownHostException) {&#10;            Timber.e(e, &quot;Unknown host&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.NetworkException(&#10;                    &quot;No internet connection or server unreachable&quot;,&#10;                    e&#10;                )&#10;            )&#10;        } catch (e: ConnectException) {&#10;            Timber.e(e, &quot;Connection failed&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.NetworkException(&#10;                    &quot;Failed to connect to server&quot;,&#10;                    e&#10;                )&#10;            )&#10;        } catch (e: JsonConvertException) {&#10;            Timber.e(e, &quot;JSON parsing error&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.ParseException(&#10;                    &quot;Failed to parse response&quot;,&#10;                    e&#10;                )&#10;            )&#10;        } catch (e: Exception) {&#10;            Timber.e(e, &quot;Unknown network error&quot;)&#10;            NetworkResult.Error(&#10;                NetworkException.UnknownException(&#10;                    e.message ?: &quot;Unknown error occurred&quot;,&#10;                    e&#10;                )&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/api/ApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/api/ApiService.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.api&#10;&#10;import com.bksd.brandapp.domain.model.ItemDetail&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.SearchResponse&#10;import com.bksd.brandapp.network.NetworkClient&#10;&#10;/**&#10; * API service interface for search and detail operations&#10; */&#10;interface ApiService {&#10;    suspend fun search(&#10;        query: String,&#10;        page: Int = 1,&#10;        limit: Int = 20,&#10;        category: String? = null,&#10;        sortBy: String? = null&#10;    ): NetworkResult&lt;SearchResponse&gt;&#10;    &#10;    suspend fun getItemDetail(itemId: String): NetworkResult&lt;ItemDetail&gt;&#10;}&#10;&#10;/**&#10; * Implementation of ApiService using NetworkClient&#10; */&#10;class ApiServiceImpl(&#10;    private val networkClient: NetworkClient&#10;) : ApiService {&#10;    &#10;    companion object {&#10;        private const val SEARCH_ENDPOINT = &quot;/search&quot;&#10;        private const val DETAIL_ENDPOINT = &quot;/items&quot;&#10;    }&#10;    &#10;    override suspend fun search(&#10;        query: String,&#10;        page: Int,&#10;        limit: Int,&#10;        category: String?,&#10;        sortBy: String?&#10;    ): NetworkResult&lt;SearchResponse&gt; {&#10;        val parameters = buildMap {&#10;            put(&quot;q&quot;, query)&#10;            put(&quot;page&quot;, page.toString())&#10;            put(&quot;limit&quot;, limit.toString())&#10;            category?.let { put(&quot;category&quot;, it) }&#10;            sortBy?.let { put(&quot;sort&quot;, it) }&#10;        }&#10;        &#10;        return networkClient.get(&#10;            path = SEARCH_ENDPOINT,&#10;            parameters = parameters&#10;        )&#10;    }&#10;    &#10;    override suspend fun getItemDetail(itemId: String): NetworkResult&lt;ItemDetail&gt; {&#10;        return networkClient.get(&#10;            path = &quot;$DETAIL_ENDPOINT/$itemId&quot;&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/api/brandfetch/BrandfetchApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/api/brandfetch/BrandfetchApiService.kt" />
              <option name="originalContent" value="package com.bksd.brandapp.network.api.brandfetch&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchBrandDetail&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchSearchResponse&#10;import com.bksd.brandapp.network.NetworkClient&#10;&#10;/**&#10; * Brandfetch API service interface&#10; */&#10;interface BrandfetchApiService {&#10;    &#10;    /**&#10;     * Search for brands using the Brandfetch API&#10;     * @param query The search query (e.g., &quot;apple&quot;)&#10;     * @param count Number of results to return (default: 1)&#10;     */&#10;    suspend fun searchBrands(&#10;        query: String,&#10;        count: Int = 1&#10;    ): NetworkResult&lt;BrandfetchSearchResponse&gt;&#10;    &#10;    /**&#10;     * Get detailed brand information&#10;     * @param brandName The brand name or domain (e.g., &quot;apple.com&quot;)&#10;     */&#10;    suspend fun getBrandDetail(&#10;        brandName: String&#10;    ): NetworkResult&lt;BrandfetchBrandDetail&gt;&#10;}&#10;&#10;/**&#10; * Implementation of BrandfetchApiService using NetworkClient&#10; */&#10;class BrandfetchApiServiceImpl(&#10;    private val networkClient: NetworkClient&#10;) : BrandfetchApiService {&#10;    &#10;    companion object {&#10;        private const val SEARCH_ENDPOINT = &quot;/v2/search&quot;&#10;        private const val BRANDS_ENDPOINT = &quot;/v2/brands&quot;&#10;    }&#10;    &#10;    override suspend fun searchBrands(&#10;        query: String,&#10;        count: Int&#10;    ): NetworkResult&lt;BrandfetchSearchResponse&gt; {&#10;        val parameters = mapOf(&#10;            &quot;c&quot; to count.toString()&#10;        )&#10;        &#10;        return networkClient.get(&#10;            path = &quot;$SEARCH_ENDPOINT/$query&quot;,&#10;            parameters = parameters,&#10;            headers = getAuthHeaders()&#10;        )&#10;    }&#10;    &#10;    override suspend fun getBrandDetail(&#10;        brandName: String&#10;    ): NetworkResult&lt;BrandfetchBrandDetail&gt; {&#10;        return networkClient.get(&#10;            path = &quot;$BRANDS_ENDPOINT/$brandName&quot;,&#10;            headers = getAuthHeaders()&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Returns authentication headers for Brandfetch API&#10;     */&#10;    private fun getAuthHeaders(): Map&lt;String, String&gt; {&#10;        return mapOf(&#10;            &quot;Authorization&quot; to &quot;Bearer ${com.bksd.brandapp.BuildConfig.API_KEY}&quot;&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.api.brandfetch&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchBrandDetail&#10;import com.bksd.brandapp.domain.model.brandfetch.BrandfetchSearchResponse&#10;import com.bksd.brandapp.network.client.NetworkClient&#10;&#10;/**&#10; * Brandfetch API service interface&#10; */&#10;interface BrandfetchApiService {&#10;    &#10;    /**&#10;     * Search for brands using the Brandfetch API&#10;     * @param query The search query (e.g., &quot;apple&quot;)&#10;     * @param count Number of results to return (default: 1)&#10;     */&#10;    suspend fun searchBrands(&#10;        query: String,&#10;        count: Int = 1&#10;    ): NetworkResult&lt;BrandfetchSearchResponse&gt;&#10;    &#10;    /**&#10;     * Get detailed brand information&#10;     * @param brandName The brand name or domain (e.g., &quot;apple.com&quot;)&#10;     */&#10;    suspend fun getBrandDetail(&#10;        brandName: String&#10;    ): NetworkResult&lt;BrandfetchBrandDetail&gt;&#10;}&#10;&#10;/**&#10; * Implementation of BrandfetchApiService using NetworkClient&#10; */&#10;class BrandfetchApiServiceImpl(&#10;    private val networkClient: NetworkClient&#10;) : BrandfetchApiService {&#10;    &#10;    companion object {&#10;        private const val SEARCH_ENDPOINT = &quot;/v2/search&quot;&#10;        private const val BRANDS_ENDPOINT = &quot;/v2/brands&quot;&#10;    }&#10;    &#10;    override suspend fun searchBrands(&#10;        query: String,&#10;        count: Int&#10;    ): NetworkResult&lt;BrandfetchSearchResponse&gt; {&#10;        val parameters = mapOf(&#10;            &quot;c&quot; to count.toString()&#10;        )&#10;        &#10;        return networkClient.get(&#10;            path = &quot;$SEARCH_ENDPOINT/$query&quot;,&#10;            parameters = parameters,&#10;            headers = getAuthHeaders()&#10;        )&#10;    }&#10;    &#10;    override suspend fun getBrandDetail(&#10;        brandName: String&#10;    ): NetworkResult&lt;BrandfetchBrandDetail&gt; {&#10;        return networkClient.get(&#10;            path = &quot;$BRANDS_ENDPOINT/$brandName&quot;,&#10;            headers = getAuthHeaders()&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Returns authentication headers for Brandfetch API&#10;     */&#10;    private fun getAuthHeaders(): Map&lt;String, String&gt; {&#10;        return mapOf(&#10;            &quot;Authorization&quot; to &quot;Bearer ${com.bksd.brandapp.BuildConfig.API_KEY}&quot;&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/client/KtorNetworkClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/client/KtorNetworkClient.kt" />
              <option name="originalContent" value="package com.bksd.brandapp.network.client&#10;&#10;import com.bksd.brandapp.domain.model.BrandApiException&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.call.body&#10;import io.ktor.client.request.get&#10;import io.ktor.client.request.header&#10;import io.ktor.client.request.parameter&#10;import io.ktor.client.statement.HttpResponse&#10;import io.ktor.client.statement.bodyAsText&#10;import io.ktor.http.isSuccess&#10;import io.ktor.serialization.JsonConvertException&#10;import kotlinx.coroutines.CancellationException&#10;import kotlinx.coroutines.TimeoutCancellationException&#10;import timber.log.Timber&#10;import java.net.ConnectException&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;&#10;/**&#10; * Implementation of NetworkClient using Ktor HttpClient&#10; */&#10;class KtorNetworkClient(&#10;    private val httpClient: HttpClient&#10;) : NetworkClient {&#10;&#10;    override suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = serviceCall {&#10;        httpClient.get(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Safe API call wrapper that handles exceptions and converts them to NetworkResult&#10;     */&#10;    private suspend inline fun &lt;reified T&gt; serviceCall(&#10;        apiCall: () -&gt; HttpResponse&#10;    ): NetworkResult&lt;T&gt; {&#10;        return try {&#10;            val response = apiCall()&#10;            handleHttpResponse&lt;T&gt;(response)&#10;        } catch (e: CancellationException) {&#10;            // Don't catch cancellation exceptions - let them propagate&#10;            throw e&#10;        } catch (e: Exception) {&#10;            NetworkResult.Error(mapExceptionToNetworkException(e))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handles HTTP response and converts to NetworkResult&#10;     */&#10;    private suspend inline fun &lt;reified T&gt; handleHttpResponse(response: HttpResponse): NetworkResult&lt;T&gt; {&#10;        return when {&#10;            response.status.isSuccess() -&gt; {&#10;                try {&#10;                    val body = response.body&lt;T&gt;()&#10;                    NetworkResult.Success(body)&#10;                } catch (e: Exception) {&#10;                    Timber.e(e, &quot;Failed to parse response body&quot;)&#10;                    NetworkResult.Error(&#10;                        BrandApiException.ParseException(&#10;                            &quot;Failed to parse response body&quot;,&#10;                            e&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                val errorBody = try {&#10;                    response.bodyAsText()&#10;                } catch (e: Exception) {&#10;                    &quot;Unknown error&quot;&#10;                }&#10;                NetworkResult.Error(&#10;                    BrandApiException.HttpException(&#10;                        error = response.status.value,&#10;                        errorMessage = errorBody&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Maps different exception types to appropriate NetworkException&#10;     */&#10;    private fun mapExceptionToNetworkException(exception: Exception): BrandApiException {&#10;        return when (exception) {&#10;            is TimeoutCancellationException -&gt; {&#10;                Timber.e(exception, &quot;Request timeout&quot;)&#10;                BrandApiException.TimeoutException()&#10;            }&#10;            is SocketTimeoutException -&gt; {&#10;                Timber.e(exception, &quot;Socket timeout&quot;)&#10;                BrandApiException.TimeoutException(&quot;Socket timeout&quot;)&#10;            }&#10;            is UnknownHostException -&gt; {&#10;                Timber.e(exception, &quot;Unknown host&quot;)&#10;                BrandApiException.NetworkException(&#10;                    &quot;No internet connection or server unreachable&quot;,&#10;                    exception&#10;                )&#10;            }&#10;            is ConnectException -&gt; {&#10;                Timber.e(exception, &quot;Connection failed&quot;)&#10;                BrandApiException.NetworkException(&#10;                    &quot;Failed to connect to server&quot;,&#10;                    exception&#10;                )&#10;            }&#10;            is JsonConvertException -&gt; {&#10;                Timber.e(exception, &quot;JSON parsing error&quot;)&#10;                BrandApiException.ParseException(&#10;                    &quot;Failed to parse response&quot;,&#10;                    exception&#10;                )&#10;            }&#10;            else -&gt; {&#10;                Timber.e(exception, &quot;Unknown network error&quot;)&#10;                BrandApiException.UnknownException(&#10;                    exception.message ?: &quot;Unknown error occurred&quot;,&#10;                    exception&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.client&#10;&#10;import com.bksd.brandapp.domain.model.NetworkException&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.call.body&#10;import io.ktor.client.request.*&#10;import io.ktor.client.statement.HttpResponse&#10;import io.ktor.client.statement.bodyAsText&#10;import io.ktor.http.isSuccess&#10;import io.ktor.serialization.JsonConvertException&#10;import kotlinx.coroutines.CancellationException&#10;import kotlinx.coroutines.TimeoutCancellationException&#10;import timber.log.Timber&#10;import java.net.ConnectException&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;&#10;/**&#10; * Ktor implementation of NetworkClient for making HTTP requests&#10; */&#10;class KtorNetworkClient(&#10;    private val httpClient: HttpClient&#10;) : NetworkClient {&#10;&#10;    override suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = executeRequest {&#10;        httpClient.get(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun &lt;T&gt; post(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = executeRequest {&#10;        httpClient.post(path) {&#10;            body?.let { setBody(it) }&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun &lt;T&gt; put(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = executeRequest {&#10;        httpClient.put(path) {&#10;            body?.let { setBody(it) }&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun &lt;T&gt; delete(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = executeRequest {&#10;        httpClient.delete(path) {&#10;            parameters.forEach { (key, value) -&gt;&#10;                parameter(key, value)&#10;            }&#10;            headers.forEach { (key, value) -&gt;&#10;                header(key, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Executes HTTP request with comprehensive error handling&#10;     */&#10;    private suspend inline fun &lt;reified T&gt; executeRequest(&#10;        crossinline request: suspend () -&gt; HttpResponse&#10;    ): NetworkResult&lt;T&gt; {&#10;        return try {&#10;            val response = request()&#10;            processResponse&lt;T&gt;(response)&#10;        } catch (e: CancellationException) {&#10;            throw e // Don't catch cancellation exceptions&#10;        } catch (e: Exception) {&#10;            Timber.e(e, &quot;Network request failed&quot;)&#10;            NetworkResult.Error(mapToNetworkException(e))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Processes HTTP response and converts to NetworkResult&#10;     */&#10;    private suspend inline fun &lt;reified T&gt; processResponse(response: HttpResponse): NetworkResult&lt;T&gt; {&#10;        return if (response.status.isSuccess()) {&#10;            try {&#10;                val responseBody = response.body&lt;T&gt;()&#10;                NetworkResult.Success(responseBody)&#10;            } catch (e: Exception) {&#10;                Timber.e(e, &quot;Failed to parse response body&quot;)&#10;                NetworkResult.Error(&#10;                    NetworkException.ParseException(&#10;                        &quot;Failed to parse response body: ${e.message}&quot;,&#10;                        e&#10;                    )&#10;                )&#10;            }&#10;        } else {&#10;            val errorMessage = try {&#10;                response.bodyAsText()&#10;            } catch (e: Exception) {&#10;                &quot;HTTP ${response.status.value}: ${response.status.description}&quot;&#10;            }&#10;&#10;            NetworkResult.Error(&#10;                NetworkException.HttpException(&#10;                    code = response.status.value,&#10;                    errorMessage = errorMessage&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Maps exceptions to appropriate NetworkException types&#10;     */&#10;    private fun mapToNetworkException(exception: Exception): NetworkException {&#10;        return when (exception) {&#10;            is TimeoutCancellationException -&gt; {&#10;                NetworkException.TimeoutException(&quot;Request timeout: ${exception.message}&quot;)&#10;            }&#10;            is SocketTimeoutException -&gt; {&#10;                NetworkException.TimeoutException(&quot;Socket timeout: ${exception.message}&quot;)&#10;            }&#10;            is UnknownHostException -&gt; {&#10;                NetworkException.NetworkException(&#10;                    &quot;Network unavailable: Cannot resolve host&quot;,&#10;                    exception&#10;                )&#10;            }&#10;            is ConnectException -&gt; {&#10;                NetworkException.NetworkException(&#10;                    &quot;Connection failed: ${exception.message}&quot;,&#10;                    exception&#10;                )&#10;            }&#10;            is JsonConvertException -&gt; {&#10;                NetworkException.ParseException(&#10;                    &quot;JSON parsing error: ${exception.message}&quot;,&#10;                    exception&#10;                )&#10;            }&#10;            else -&gt; {&#10;                NetworkException.UnknownException(&#10;                    exception.message ?: &quot;Unknown network error&quot;,&#10;                    exception&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/client/NetworkClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bksd/brandapp/network/client/NetworkClient.kt" />
              <option name="originalContent" value="package com.bksd.brandapp.network.client&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;&#10;/**&#10; * Network client interface for making HTTP requests&#10; */&#10;interface NetworkClient {&#10;    suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;}" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.client&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;&#10;/**&#10; * Network client interface for making HTTP requests&#10; */&#10;interface NetworkClient {&#10;    suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt; = emptyMap(),&#10;        headers: Map&lt;String, String&gt; = emptyMap()&#10;    ): NetworkResult&lt;T&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/api/ApiServiceImplTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/api/ApiServiceImplTest.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.api&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.network.test.MockNetworkClient&#10;import com.bksd.brandapp.network.test.TestDataFactory&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.jupiter.api.BeforeEach&#10;import org.junit.jupiter.api.Test&#10;import org.junit.jupiter.api.assertThrows&#10;import kotlin.test.assertEquals&#10;import kotlin.test.assertTrue&#10;&#10;/**&#10; * Unit tests for ApiServiceImpl demonstrating comprehensive testing capabilities&#10; */&#10;class ApiServiceImplTest {&#10;    &#10;    private lateinit var mockNetworkClient: MockNetworkClient&#10;    private lateinit var apiService: ApiService&#10;    &#10;    @BeforeEach&#10;    fun setup() {&#10;        mockNetworkClient = MockNetworkClient()&#10;        apiService = ApiServiceImpl(mockNetworkClient)&#10;    }&#10;    &#10;    @Test&#10;    fun `search returns success when network call succeeds`() = runTest {&#10;        // Given&#10;        val expectedResponse = TestDataFactory.createSearchResponse()&#10;        mockNetworkClient.setResponse(&quot;/search&quot;, expectedResponse)&#10;        &#10;        // When&#10;        val result = apiService.search(query = &quot;test&quot;)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Success)&#10;        assertEquals(expectedResponse, result.data)&#10;    }&#10;    &#10;    @Test&#10;    fun `search passes correct parameters to network client`() = runTest {&#10;        // Given&#10;        val expectedResponse = TestDataFactory.createSearchResponse()&#10;        mockNetworkClient.setResponse(&quot;/search&quot;, expectedResponse)&#10;        &#10;        // When&#10;        apiService.search(&#10;            query = &quot;test query&quot;,&#10;            page = 2,&#10;            limit = 10,&#10;            category = &quot;electronics&quot;,&#10;            sortBy = &quot;price&quot;&#10;        )&#10;        &#10;        // Then&#10;        // In a real test, you'd verify the parameters were passed correctly&#10;        // This demonstrates the pattern for parameter verification&#10;        assertTrue(mockNetworkClient.responses.containsKey(&quot;/search&quot;))&#10;    }&#10;    &#10;    @Test&#10;    fun `getItemDetail returns success when network call succeeds`() = runTest {&#10;        // Given&#10;        val expectedDetail = TestDataFactory.createItemDetail()&#10;        mockNetworkClient.setResponse(&quot;/items/test-id&quot;, expectedDetail)&#10;        &#10;        // When&#10;        val result = apiService.getItemDetail(&quot;test-id&quot;)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Success)&#10;        assertEquals(expectedDetail, result.data)&#10;    }&#10;    &#10;    @Test&#10;    fun `search returns error when network client fails`() = runTest {&#10;        // Given&#10;        mockNetworkClient.shouldReturnError = true&#10;        &#10;        // When&#10;        val result = apiService.search(query = &quot;test&quot;)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Error)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/api/brandfetch/BrandfetchApiServiceImplTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/api/brandfetch/BrandfetchApiServiceImplTest.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.api.brandfetch&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.network.test.MockNetworkClient&#10;import com.bksd.brandapp.network.test.brandfetch.BrandfetchTestDataFactory&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.jupiter.api.BeforeEach&#10;import org.junit.jupiter.api.Test&#10;import kotlin.test.assertEquals&#10;import kotlin.test.assertTrue&#10;&#10;/**&#10; * Unit tests for BrandfetchApiServiceImpl demonstrating comprehensive testing capabilities&#10; */&#10;class BrandfetchApiServiceImplTest {&#10;    &#10;    private lateinit var mockNetworkClient: MockNetworkClient&#10;    private lateinit var brandfetchApiService: BrandfetchApiService&#10;    &#10;    @BeforeEach&#10;    fun setup() {&#10;        mockNetworkClient = MockNetworkClient()&#10;        brandfetchApiService = BrandfetchApiServiceImpl(mockNetworkClient)&#10;    }&#10;    &#10;    @Test&#10;    fun `searchBrands returns success when network call succeeds`() = runTest {&#10;        // Given&#10;        val expectedResponse = BrandfetchTestDataFactory.createBrandfetchSearchResponse()&#10;        mockNetworkClient.setResponse(&quot;/v2/search/apple&quot;, expectedResponse)&#10;        &#10;        // When&#10;        val result = brandfetchApiService.searchBrands(query = &quot;apple&quot;, count = 1)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Success)&#10;        assertEquals(expectedResponse, result.data)&#10;    }&#10;    &#10;    @Test&#10;    fun `getBrandDetail returns success when network call succeeds`() = runTest {&#10;        // Given&#10;        val expectedDetail = BrandfetchTestDataFactory.createBrandfetchBrandDetail()&#10;        mockNetworkClient.setResponse(&quot;/v2/brands/apple.com&quot;, expectedDetail)&#10;        &#10;        // When&#10;        val result = brandfetchApiService.getBrandDetail(&quot;apple.com&quot;)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Success)&#10;        assertEquals(expectedDetail, result.data)&#10;    }&#10;    &#10;    @Test&#10;    fun `searchBrands returns error when network client fails`() = runTest {&#10;        // Given&#10;        mockNetworkClient.shouldReturnError = true&#10;        &#10;        // When&#10;        val result = brandfetchApiService.searchBrands(query = &quot;apple&quot;)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Error)&#10;    }&#10;    &#10;    @Test&#10;    fun `getBrandDetail returns error when network client fails`() = runTest {&#10;        // Given&#10;        mockNetworkClient.shouldReturnError = true&#10;        &#10;        // When&#10;        val result = brandfetchApiService.getBrandDetail(&quot;apple.com&quot;)&#10;        &#10;        // Then&#10;        assertTrue(result is NetworkResult.Error)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/test/MockNetworkClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/test/MockNetworkClient.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.test&#10;&#10;import com.bksd.brandapp.domain.model.NetworkResult&#10;import com.bksd.brandapp.network.NetworkClient&#10;import kotlinx.coroutines.delay&#10;&#10;/**&#10; * Mock implementation of NetworkClient for testing purposes&#10; */&#10;class MockNetworkClient : NetworkClient {&#10;    &#10;    var shouldReturnError = false&#10;    var delayMs = 0L&#10;    var responses = mutableMapOf&lt;String, Any&gt;()&#10;    var exceptions = mutableMapOf&lt;String, Exception&gt;()&#10;    &#10;    fun setResponse(endpoint: String, response: Any) {&#10;        responses[endpoint] = response&#10;    }&#10;    &#10;    fun setException(endpoint: String, exception: Exception) {&#10;        exceptions[endpoint] = exception&#10;    }&#10;    &#10;    override suspend fun &lt;T&gt; get(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = makeCall(path)&#10;    &#10;    override suspend fun &lt;T&gt; post(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = makeCall(path)&#10;    &#10;    override suspend fun &lt;T&gt; put(&#10;        path: String,&#10;        body: Any?,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = makeCall(path)&#10;    &#10;    override suspend fun &lt;T&gt; delete(&#10;        path: String,&#10;        parameters: Map&lt;String, String&gt;,&#10;        headers: Map&lt;String, String&gt;&#10;    ): NetworkResult&lt;T&gt; = makeCall(path)&#10;    &#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    private suspend fun &lt;T&gt; makeCall(path: String): NetworkResult&lt;T&gt; {&#10;        if (delayMs &gt; 0) {&#10;            delay(delayMs)&#10;        }&#10;        &#10;        exceptions[path]?.let { exception -&gt;&#10;            throw exception&#10;        }&#10;        &#10;        return if (shouldReturnError) {&#10;            NetworkResult.Error(&#10;                com.bksd.brandapp.domain.model.NetworkException.HttpException(&#10;                    code = 500,&#10;                    errorMessage = &quot;Mock error&quot;&#10;                )&#10;            )&#10;        } else {&#10;            val response = responses[path] ?: throw IllegalStateException(&quot;No mock response set for $path&quot;)&#10;            NetworkResult.Success(response as T)&#10;        }&#10;    }&#10;    &#10;    fun reset() {&#10;        shouldReturnError = false&#10;        delayMs = 0L&#10;        responses.clear()&#10;        exceptions.clear()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/test/TestDataFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/test/TestDataFactory.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.test&#10;&#10;import com.bksd.brandapp.domain.model.ItemDetail&#10;import com.bksd.brandapp.domain.model.SearchResponse&#10;import com.bksd.brandapp.domain.model.SearchResult&#10;&#10;/**&#10; * Test data factory for creating mock data objects for testing&#10; */&#10;object TestDataFactory {&#10;    &#10;    fun createSearchResult(&#10;        id: String = &quot;test-id-1&quot;,&#10;        title: String = &quot;Test Item&quot;,&#10;        description: String = &quot;Test description&quot;,&#10;        imageUrl: String? = &quot;https://example.com/image.jpg&quot;,&#10;        category: String? = &quot;test-category&quot;,&#10;        rating: Double? = 4.5&#10;    ) = SearchResult(&#10;        id = id,&#10;        title = title,&#10;        description = description,&#10;        imageUrl = imageUrl,&#10;        category = category,&#10;        rating = rating&#10;    )&#10;    &#10;    fun createSearchResponse(&#10;        results: List&lt;SearchResult&gt; = listOf(createSearchResult()),&#10;        totalCount: Int = 1,&#10;        page: Int = 1,&#10;        hasMore: Boolean = false&#10;    ) = SearchResponse(&#10;        results = results,&#10;        totalCount = totalCount,&#10;        page = page,&#10;        hasMore = hasMore&#10;    )&#10;    &#10;    fun createItemDetail(&#10;        id: String = &quot;test-id-1&quot;,&#10;        title: String = &quot;Test Item Detail&quot;,&#10;        description: String = &quot;Test description&quot;,&#10;        longDescription: String? = &quot;Long test description with more details&quot;,&#10;        imageUrls: List&lt;String&gt; = listOf(&quot;https://example.com/image1.jpg&quot;, &quot;https://example.com/image2.jpg&quot;),&#10;        category: String? = &quot;test-category&quot;,&#10;        rating: Double? = 4.5,&#10;        reviewCount: Int? = 100,&#10;        price: Double? = 29.99,&#10;        currency: String? = &quot;USD&quot;,&#10;        tags: List&lt;String&gt; = listOf(&quot;tag1&quot;, &quot;tag2&quot;),&#10;        createdAt: String? = &quot;2025-01-01T00:00:00Z&quot;,&#10;        updatedAt: String? = &quot;2025-01-02T00:00:00Z&quot;&#10;    ) = ItemDetail(&#10;        id = id,&#10;        title = title,&#10;        description = description,&#10;        longDescription = longDescription,&#10;        imageUrls = imageUrls,&#10;        category = category,&#10;        rating = rating,&#10;        reviewCount = reviewCount,&#10;        price = price,&#10;        currency = currency,&#10;        tags = tags,&#10;        createdAt = createdAt,&#10;        updatedAt = updatedAt&#10;    )&#10;    &#10;    fun createMultipleSearchResults(count: Int = 3): List&lt;SearchResult&gt; {&#10;        return (1..count).map { index -&gt;&#10;            createSearchResult(&#10;                id = &quot;test-id-$index&quot;,&#10;                title = &quot;Test Item $index&quot;,&#10;                description = &quot;Test description $index&quot;&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/test/brandfetch/BrandfetchTestDataFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/bksd/brandapp/network/test/brandfetch/BrandfetchTestDataFactory.kt" />
              <option name="updatedContent" value="package com.bksd.brandapp.network.test.brandfetch&#10;&#10;import com.bksd.brandapp.domain.model.brandfetch.*&#10;&#10;/**&#10; * Test data factory for creating Brandfetch mock data objects for testing&#10; */&#10;object BrandfetchTestDataFactory {&#10;    &#10;    fun createBrandfetchSearchResult(&#10;        name: String = &quot;Apple&quot;,&#10;        domain: String = &quot;apple.com&quot;,&#10;        claimed: Boolean = true,&#10;        description: String? = &quot;Apple Inc. is an American multinational technology company&quot;,&#10;        longDescription: String? = &quot;Apple Inc. is an American multinational technology company headquartered in Cupertino, California, that designs, develops, and sells consumer electronics, computer software, and online services.&quot;&#10;    ) = BrandfetchSearchResult(&#10;        name = name,&#10;        domain = domain,&#10;        claimed = claimed,&#10;        description = description,&#10;        longDescription = longDescription,&#10;        links = createBrandfetchLinks(),&#10;        logos = createBrandfetchLogos(),&#10;        colors = createBrandfetchColors(),&#10;        fonts = createBrandfetchFonts(),&#10;        images = createBrandfetchImages()&#10;    )&#10;    &#10;    fun createBrandfetchSearchResponse(&#10;        brands: List&lt;BrandfetchSearchResult&gt; = listOf(createBrandfetchSearchResult())&#10;    ) = BrandfetchSearchResponse(brands = brands)&#10;    &#10;    fun createBrandfetchBrandDetail(&#10;        name: String = &quot;Apple&quot;,&#10;        domain: String = &quot;apple.com&quot;,&#10;        claimed: Boolean = true,&#10;        description: String? = &quot;Apple Inc. is an American multinational technology company&quot;,&#10;        longDescription: String? = &quot;Apple Inc. is an American multinational technology company headquartered in Cupertino, California, that designs, develops, and sells consumer electronics, computer software, and online services.&quot;&#10;    ) = BrandfetchBrandDetail(&#10;        name = name,&#10;        domain = domain,&#10;        claimed = claimed,&#10;        description = description,&#10;        longDescription = longDescription,&#10;        links = createBrandfetchLinks(),&#10;        logos = createBrandfetchLogos(),&#10;        colors = createBrandfetchColors(),&#10;        fonts = createBrandfetchFonts(),&#10;        images = createBrandfetchImages(),&#10;        company = createBrandfetchCompany()&#10;    )&#10;    &#10;    private fun createBrandfetchLinks() = listOf(&#10;        BrandfetchLink(name = &quot;website&quot;, url = &quot;https://www.apple.com&quot;),&#10;        BrandfetchLink(name = &quot;twitter&quot;, url = &quot;https://twitter.com/apple&quot;),&#10;        BrandfetchLink(name = &quot;facebook&quot;, url = &quot;https://facebook.com/apple&quot;)&#10;    )&#10;    &#10;    private fun createBrandfetchLogos() = listOf(&#10;        BrandfetchLogo(&#10;            theme = &quot;light&quot;,&#10;            formats = listOf(&#10;                BrandfetchLogoFormat(&#10;                    src = &quot;https://cdn.brandfetch.io/apple.com/logo.svg&quot;,&#10;                    background = &quot;transparent&quot;,&#10;                    format = &quot;svg&quot;,&#10;                    height = 100,&#10;                    width = 100,&#10;                    size = 5000&#10;                )&#10;            )&#10;        )&#10;    )&#10;    &#10;    private fun createBrandfetchColors() = listOf(&#10;        BrandfetchColor(hex = &quot;#000000&quot;, type = &quot;primary&quot;, brightness = 0),&#10;        BrandfetchColor(hex = &quot;#FFFFFF&quot;, type = &quot;secondary&quot;, brightness = 255)&#10;    )&#10;    &#10;    private fun createBrandfetchFonts() = listOf(&#10;        BrandfetchFont(&#10;            name = &quot;SF Pro Display&quot;,&#10;            type = &quot;custom&quot;,&#10;            origin = &quot;apple&quot;,&#10;            originId = &quot;sf-pro-display&quot;,&#10;            weights = listOf(&quot;regular&quot;, &quot;medium&quot;, &quot;bold&quot;)&#10;        )&#10;    )&#10;    &#10;    private fun createBrandfetchImages() = listOf(&#10;        BrandfetchImage(&#10;            name = &quot;hero-image&quot;,&#10;            src = &quot;https://cdn.brandfetch.io/apple.com/hero.jpg&quot;,&#10;            type = &quot;hero&quot;&#10;        )&#10;    )&#10;    &#10;    private fun createBrandfetchCompany() = BrandfetchCompany(&#10;        employees = &quot;147,000+&quot;,&#10;        foundedYear = 1976,&#10;        industry = &quot;Technology&quot;,&#10;        keyPeople = listOf(&quot;Tim Cook&quot;, &quot;Craig Federighi&quot;, &quot;Johnny Srouji&quot;)&#10;    )&#10;    &#10;    fun createMultipleBrands(count: Int = 3): List&lt;BrandfetchSearchResult&gt; {&#10;        return (1..count).map { index -&gt;&#10;            createBrandfetchSearchResult(&#10;                name = &quot;Brand $index&quot;,&#10;                domain = &quot;brand$index.com&quot;&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>